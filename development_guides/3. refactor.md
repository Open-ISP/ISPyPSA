Refactor draft monolithic function to a set control and process functions according to the following
   architectural principles:

 - The codebase should contain two types of functions:
   - Control functions: These contain can contain the following elements
     - simple object in object out function calls
     - indexing or subscripting to retrieve input and output values from objects
     - simple if statements where needed to determine if a lower level function
       should be run
   - Processing functions: Processing functions are any functions that don't
     meet the definition of control functions. They typically contain things
     like:
     - for loops
     - complex if statements
     - complex chained method calls
     - complex dataframe manipulations
   - Functions should fall cleanly into one category of function or the other.
     If it mostly looks like a control function it should be refactored to
     place any processing elements into sub functions so it becomes a pure
     control function. If a function is longer than 20 lines it should be
     refactored into a control function. Control functions can be longer
     because they are easy to read.

 - Higher level functions should go at the top of a file. A function
   definition should immediately be followed by the definition of
   any locally defined (same file) functions which it calls.

 - Features should be implemented with a functional core. This means data
   io should be done in a highlevel control function such that lowerlevel
   control and processing functions can be tested using simple data in
   data out unit testing, with minimal mocking required.

 - Within the context of a feature you are working assume the code you are
   working is trustworthy and working properly. Therefore, there isn't a
   need to defensively check if inputs are none or empty if they should
   contain real values for the case being handled. This is to improve
   readability by reducing clutter.
